{"version":3,"file":"content_script.js","mappings":";;;;;;;;;;;;;;;AAAA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,WAAW,QAAQ;AACnB,WAAW,OAAO,mGAAmG,iCAAiC;AACtJ,WAAW,QAAQ,wCAAwC,0BAA0B;AACrF,WAAW,QAAQ,8CAA8C,0BAA0B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3EA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kBAAkB;AACrE;AACA;AACA;AACA;AACA;;;;;;UCtCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACN4D;AAC+B;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8EAAuB;AAC5E;AACA;AACA;AACA;AACA,yBAAyB,4BAA4B;AACrD;AACA,sCAAsC,8EAAuB;AAC7D;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8EAAuB;AAC1D,sCAAsC,8EAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,uEAAuE,2BAA2B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAW;AACxB;AACA;AACA,qCAAqC,yDAAO,CAAC,6DAAW;AACxD,qCAAqC,yDAAO,CAAC,6DAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAW;AACxB;AACA;AACA,aAAa,6DAAW;AACxB;AACA;AACA,aAAa,6DAAW;AACxB;AACA;AACA,aAAa,6DAAW;AACxB;AACA,4CAA4C,yDAAO,CAAC,6DAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,I","sources":["webpack://re-search-extension/./src/highlight_replacement.js","webpack://re-search-extension/./src/message_protocol.js","webpack://re-search-extension/webpack/bootstrap","webpack://re-search-extension/webpack/runtime/define property getters","webpack://re-search-extension/webpack/runtime/hasOwnProperty shorthand","webpack://re-search-extension/webpack/runtime/make namespace object","webpack://re-search-extension/./src/re_search.js"],"sourcesContent":["/** Options interface for styling highlighted text. */\r\nexport const DefaultHighlightOptions = {\r\n    color: \"white\",\r\n    backgroundColor: \"green\",\r\n}\r\n\r\n/** Class name for <a> elements containing matched text. */\r\nconst NON_MATCH_CLASS = \"re-search_non_matching\";\r\n/** Class name for <a> elmenets containing matched text. */\r\nconst MATCH_CLASS = \"re-search_matching\";\r\n\r\n/**\r\n * Helper function for {@link HighlightReplacement}. Creates an element holding slices of a given string, divided according to a sorted, two-dimensional array of index ranges.\r\n * @param {string} str \r\n * @param {Array} segmentRanges Two-dimensional array of the form [[x, y],...]. Follows the same index semantics of {@link String.prototype.substring}.\r\n * @param {string} textColor Color string compatible with {@link CSSStyleDeclaration}.\r\n * @param {string} backgroundColor Color string compatible with {@link CSSStyleDeclaration}.\r\n * @returns Returns an element that may contain multiple text segments contained in their own <a> elements.\r\n */\r\nfunction SeparateString(str, segmentRanges, textColor = \"\", backgroundColor = \"\") {\r\n    let stringPointer = 0;\r\n    let container = document.createElement('span');\r\n    let rightBound = segmentRanges[segmentRanges.length - 1][1];\r\n\r\n    for (let pair of segmentRanges) {\r\n        let enc = CreateTextElement(str.substring(pair[0], pair[1]));\r\n        enc.style.color = textColor;\r\n        enc.style.backgroundColor = backgroundColor;\r\n        enc.className = MATCH_CLASS;\r\n        if (pair[0] > stringPointer) {\r\n            let nonmatch = CreateTextElement(str.substring(stringPointer, pair[0]));\r\n            nonmatch.className = NON_MATCH_CLASS;\r\n            container.appendChild(nonmatch);\r\n        }\r\n        stringPointer = pair[1];\r\n        container.appendChild(enc);\r\n    }\r\n    if (rightBound < str.length) {\r\n        container.appendChild(CreateTextElement(str.substring(rightBound, str.length)));\r\n    }\r\n    return container;\r\n}\r\n\r\n/**\r\n * For every Text node that has a match, we'll need to separate the matches into their own element so that we can apply highlightning. This needs to be a reversible process so our replacement will\r\n * be kept as one entity and carry a reference to the Text it just replaced.\r\n */\r\nexport class HighlightReplacement {\r\n    constructor(matchRanges = [[0, 0]], textnode = null, colorOptions = DefaultHighlightOptions) {\r\n        let text = (textnode)? textnode.data: \"\";\r\n        /**@type HTMLSpanElement */\r\n        this.wrapper = SeparateString(text, matchRanges, colorOptions.color, colorOptions.backgroundColor);\r\n        /**@type Node */\r\n        this.swap = textnode;\r\n    }\r\n    /** Swaps the wrapper element with the Text node it originally replaced. This also reassigns all fields to null to avoid potential memory leaks. */\r\n    Unswap() {\r\n        this.wrapper.replaceWith(this.swap);\r\n        this.wrapper = null;\r\n        this.swap = null;\r\n    }\r\n    /** Swaps the Text node with the wrapper it is meant to replace. */\r\n    Swap() {\r\n        if (this.swap)\r\n            this.swap.parentElement.replaceChild(this.wrapper, this.swap);\r\n    }\r\n    /** Changes the highlight color scheme. */\r\n    ChangeColor(colorObj = DefaultHighlightOptions) {\r\n        for (let el of this.wrapper.children) {\r\n            if (el.className == MATCH_CLASS) {\r\n                el.style.color = colorObj.color;\r\n                el.style.backgroundColor = colorObj.backgroundColor\r\n            }\r\n        }\r\n    }\r\n}","\r\nexport const MessageType = {\r\n    \"SEARCH\": 1,\r\n    \"JUMP_TO\": 2,\r\n    \"CLEAR\": 3,\r\n    \"CHANGE_COLOR\": 4,\r\n    \"GET_NUM\": 5,\r\n    \"SENT_NUM\": 6,\r\n    \"GET_MAX\": 7,\r\n    \"SENT_MAX\": 8\r\n};\r\n\r\n/**\r\n * Invert key-value of MessageType so we have a two-way association\r\n */\r\nexport const MessageTypeInverse = InvertEnumKeyValue(MessageType);\r\n\r\nfunction InvertEnumKeyValue(obj) {\r\n    let o = {};\r\n    for (let key of Object.keys(obj)) {\r\n        o[obj[key]] = key;\r\n    }\r\n    return o;\r\n}\r\n\r\nexport class Message {\r\n    constructor(msgtype, params) {\r\n        if (!MessageType.hasOwnKeys(msgtype)) throw new Error('Invalid message type');\r\n        this.command = msgtype;\r\n        this.params = params;\r\n    }\r\n    /**\r\n     * For debugging purposes.\r\n     * @returns Name of the code corresponding to {@link MessageType}.\r\n     */\r\n    GetTypeString() {\r\n        return MessageTypeInverse[this.command];\r\n    }\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { Message, MessageType } from './message_protocol.js'\r\nimport { DefaultHighlightOptions, HighlightReplacement } from './highlight_replacement.js';\r\n\r\n(() => {\r\n\r\nconst TAGNAME_EXCLUDE = {\r\n    \"SCRIPT\": true,\r\n    \"STYLE\": true,\r\n}\r\n\r\nif (window.hasRun) return;\r\nwindow.hasRun = true;\r\n\r\n/**\r\n * Retrieve an array containing all Text {@link Node}s within the given element including its children.\r\n * @param parentNode\r\n */\r\nfunction AggregateTextNodes(parentNode) {\r\n    let list = [];\r\n    let subqueue = [];\r\n    subqueue.push(parentNode);\r\n\r\n    while (subqueue.length > 0) {\r\n        let parent = subqueue.shift();\r\n        // push subnodes into the queue\r\n        for (let child of parent.children) {\r\n            subqueue.push(child);\r\n        }\r\n\r\n        for (let node of parent.childNodes) {\r\n            // The contents of script elements will show up as text nodes so filter them here\r\n            if (node.nodeType == Node.TEXT_NODE && node.parentElement && !TAGNAME_EXCLUDE[node.parentElement.tagName]) {\r\n                list.push(node);\r\n            }\r\n        }\r\n\r\n    }\r\n    return list;\r\n}\r\n/**\r\n * Returns a simple object with the same property names as a default object. If a given object shares a property name, use the given object's property value instead. Note this function does not expected nested objects in either parameter.\r\n * @param {object} defaultOptions An options object. The returned object will have indentical property names to this object.\r\n * @param {object} givenOptions An options object. Any property name shared with defaultOptions will use this object's value in the returned object.\r\n * @returns \r\n */\r\nfunction SafeConfigParse(defaultOptions, givenOptions) {\r\n    let finalSettings = {};\r\n    for (let setting of Object.keys(defaultOptions)) {\r\n        if (givenOptions.hasOwnProperty(setting)) {\r\n            finalSettings[setting] = givenOptions[setting];\r\n        } else {\r\n            finalSettings[setting] = defaultOptions[setting];\r\n        }\r\n    }\r\n    return finalSettings;\r\n}\r\n\r\n/** \r\n * Utility function to make an inline element containing only our text.\r\n * @param {string} text The text to appear in the created element.\r\n * @returns An <a> element with the given text, set to display as an inline block.\r\n */\r\nfunction CreateTextElement(text) {\r\n    let e = document.createElement('span');\r\n    let t = document.createTextNode(text);\r\n    e.appendChild(t);\r\n    return e;\r\n}\r\n\r\n/**\r\n * This class should be the container for state information.\r\n */\r\nclass Searcher {\r\n    constructor(root = document.body, colorOptions = DefaultHighlightOptions) {\r\n        /** The first node to start searching from. */\r\n        this.RootNode = root;\r\n        /** List of all Text nodes present in the DOM body. */\r\n        this.TextNodes = AggregateTextNodes(root);\r\n        /** List of all {@link HighlightReplacement} created by the last search call. */\r\n        this.ReplacedText = [];\r\n        this.colors = SafeConfigParse(DefaultHighlightOptions, colorOptions);\r\n\r\n        console.log(`Processed ${this.TextNodes.length} Text node(s)`);\r\n        \r\n    }\r\n    UpdateRoot(newRoot) {\r\n        this.RootNode = newRoot;\r\n    }\r\n    /**\r\n     * Call this if text on the DOM has changed.\r\n     */\r\n    Update() {\r\n        this.Revert();\r\n        this.TextNodes = AggregateTextNodes(this.RootNode);\r\n    }\r\n    /**\r\n     * Call to restore the original document.\r\n     */\r\n    Revert() {\r\n        for (let swapped of this.ReplacedText) {\r\n            swapped.Unswap();\r\n        }\r\n        this.ReplacedText = [];\r\n    }\r\n    /**\r\n     * Carry out a search of all strings within {@link TextNodes} and highlight matched text in the DOM.\r\n     * @param {string} searchstr \r\n     */\r\n    Search(searchstr, multiFlag = true, caseFlag = false) {\r\n        debugger;\r\n        if (this.ReplacedText.length > 1) this.Revert();\r\n        if (searchstr.length === 0) return;\r\n\r\n        let flags = \"g\";\r\n        if (multiFlag) flags += \"m\";\r\n        if (caseFlag) flags += \"i\"\r\n        let searchExpression = new RegExp(searchstr, flags);\r\n\r\n        for (let tnode of this.TextNodes) {\r\n            let matches = [...tnode.data.matchAll(searchExpression)];\r\n            // Observed some that some text nodes have a null parentElement/parentNode\r\n            if (matches.length > 0 && tnode.parentElement) {\r\n                let ranges = matches.map(\r\n                    (result) => [result.index, result.index + result[0].length]\r\n                );\r\n                let swappedElement = new HighlightReplacement(ranges, tnode);\r\n                this.ReplacedText.push(swappedElement);\r\n                swappedElement.Swap();\r\n            }\r\n        }\r\n    }\r\n\r\n    ChangeHighlightColor(options = DefaultHighlightOptions) {\r\n        this.colors = SafeConfigParse(DefaultHighlightOptions, options);\r\n        for (let matchedElement of this.ReplacedText) {\r\n            matchedElement.ChangeColor(this.colors);\r\n        }\r\n    }\r\n    /**\r\n     * Function to scroll the matched element into view.\r\n     * @param {*} index \r\n     * @returns \r\n     */\r\n    JumpTo(index) {\r\n        if (this.ReplacedText.length == 0) return;\r\n        else {\r\n            this.ReplacedText[index].wrapper.scrollIntoView();\r\n        }\r\n    }\r\n    /**\r\n     * \r\n     * @returns Number of regex matches.\r\n     */\r\n    GetNumMatches() {\r\n        return this.ReplacedText.length;\r\n    }\r\n    /**\r\n     * \r\n     * @param {number} index The index of the desired match.\r\n     * @returns Returns null if index is invalid, otherwise returns a {@link HighlightReplacement}.\r\n     */\r\n    GetMatchInfo(index) {\r\n        if (index >= this.ReplacedText.length || index < 0) return null;\r\n        return this.ReplacedText[index];\r\n    }\r\n}\r\n\r\nlet searchInstance = new Searcher(document.body);\r\n\r\n/**\r\n * Event handler to handle search requests from our browser action.\r\n * @param message \r\n */\r\nfunction SearchEventHandler(message) {\r\n    if (!message) return;\r\n    switch(message.command) {\r\n        case MessageType.SEARCH:\r\n            searchInstance.Revert();\r\n            searchInstance.Search(message.params[0]);\r\n            let sentNumMessage = new Message(MessageType.SENT_NUM, null);\r\n            let sentMaxMessage = new Message(MessageType.SENT_MAX, [0]);\r\n            if (searchInstance.GetNumMatches() != 0) {\r\n                sentNumMessage.params = [0, searchInstance.GetMatchInfo(0)];\r\n                sentMaxMessage.params[0] = searchinstance.GetNumMatches();\r\n                browser.runtime.sendMessage(sentNumMessage);\r\n                browser.runtime.sendMessage(sentMaxMessage);\r\n            }\r\n            break;\r\n        case MessageType.CHANGE_COLOR:\r\n            searchInstance.ChangeHighlightColor(message.params[0]);\r\n            break;\r\n        case MessageType.CLEAR:\r\n            searchInstance.Revert();\r\n            break;\r\n        case MessageType.JUMP_TO:\r\n            searchInstance.JumpTo(message.params[0]);\r\n            break;\r\n        case MessageType.GET_NUM:\r\n            let match = searchInstance.GetMatchInfo(message.params[0]);\r\n            browser.runtime.sendMessage(new Message(MessageType.SENT_NUM, [message.params[0], match]));\r\n        default:\r\n            break;\r\n    }\r\n}\r\n\r\nbrowser.runtime.onMessage.addListener(SearchEventHandler);\r\n})();"],"names":[],"sourceRoot":""}